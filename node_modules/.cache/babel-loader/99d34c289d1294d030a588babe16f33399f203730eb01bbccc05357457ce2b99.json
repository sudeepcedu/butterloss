{"ast":null,"code":"import { isSameDay } from 'date-fns';\n\n// Constants\nconst CALORIES_PER_KG_FAT = 7716.17; // calories needed to lose 1kg of fat\nconst CALORIES_PER_BUTTER_PACK = 770; // 770 calories = 1 butter pack (100g fat)\nconst CALORIES_PER_GHEE_PACK = 7700; // 7700 calories = 1 ghee pack (1kg fat)\n\nexport const calculateTotalDeficitNeeded = targetLoss => {\n  const exactDeficit = targetLoss * CALORIES_PER_KG_FAT;\n  // Round to nearest 100 calories for a nice round number\n  return Math.round(exactDeficit / 100) * 100;\n};\nexport const calculateCurrentDeficit = logs => {\n  return logs.reduce((total, log) => total + (log.deficit || 0), 0);\n};\nexport const calculateRemainingDeficit = (totalNeeded, current) => {\n  return Math.max(0, totalNeeded - current);\n};\nexport const calculateButterPacks = logs => {\n  // Only count positive deficits for butter packs\n  const positiveDeficit = logs.reduce((total, log) => total + Math.max(0, log.deficit || 0), 0);\n  return Math.floor(positiveDeficit / CALORIES_PER_BUTTER_PACK);\n};\nexport const calculateGheePacks = logs => {\n  // Only count positive deficits for ghee packs\n  const positiveDeficit = logs.reduce((total, log) => total + Math.max(0, log.deficit || 0), 0);\n  return Math.floor(positiveDeficit / CALORIES_PER_GHEE_PACK);\n};\nexport const calculateCurrentStreak = logs => {\n  // Sort logs by date in descending order (most recent first)\n  const sortedLogs = [...logs].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n  if (sortedLogs.length === 0) return 0;\n  const today = new Date();\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n\n  // Check if we have an entry for today\n  const todayLog = sortedLogs.find(log => isSameDay(new Date(log.date), today));\n  const yesterdayLog = sortedLogs.find(log => isSameDay(new Date(log.date), yesterday));\n\n  // If no entry for today, check if yesterday had a positive deficit\n  if (!todayLog) {\n    if (!yesterdayLog || (yesterdayLog.deficit || 0) <= 0) {\n      return 0; // No streak if yesterday is missing or had non-positive deficit\n    }\n    // Yesterday had positive deficit but no today entry - streak is 1\n    return 1;\n  }\n\n  // If today's entry exists but is not positive, no streak\n  if ((todayLog.deficit || 0) <= 0) {\n    return 0;\n  }\n\n  // Start counting from today\n  let streak = 1;\n  let currentDate = new Date(todayLog.date);\n\n  // Check consecutive days backwards\n  for (let i = 1; i < sortedLogs.length; i++) {\n    const log = sortedLogs[i];\n    const logDate = new Date(log.date);\n    const daysDiff = Math.floor((currentDate.getTime() - logDate.getTime()) / (1000 * 60 * 60 * 24));\n    if (daysDiff === 1 && (log.deficit || 0) > 0) {\n      streak++;\n      currentDate = logDate;\n    } else {\n      break; // Gap in days or non-positive deficit, streak broken\n    }\n  }\n  return streak;\n};\nexport const calculateEstimatedDays = (remainingDeficit, dailyDeficit) => {\n  if (dailyDeficit <= 0) return Infinity;\n  return Math.ceil(remainingDeficit / dailyDeficit);\n};\nexport const calculateAverageDailyDeficit = logs => {\n  if (logs.length === 0) return 0;\n  const totalDeficit = logs.reduce((sum, log) => sum + (log.deficit || 0), 0);\n  return totalDeficit / logs.length;\n};\nexport const calculateBMI = (weight, height) => {\n  const heightInMeters = height / 100;\n  return weight / (heightInMeters * heightInMeters);\n};\nexport const getBMICategory = bmi => {\n  if (bmi < 18.5) return 'Underweight';\n  if (bmi < 25) return 'Normal weight';\n  if (bmi < 30) return 'Overweight';\n  return 'Obese';\n};","map":{"version":3,"names":["isSameDay","CALORIES_PER_KG_FAT","CALORIES_PER_BUTTER_PACK","CALORIES_PER_GHEE_PACK","calculateTotalDeficitNeeded","targetLoss","exactDeficit","Math","round","calculateCurrentDeficit","logs","reduce","total","log","deficit","calculateRemainingDeficit","totalNeeded","current","max","calculateButterPacks","positiveDeficit","floor","calculateGheePacks","calculateCurrentStreak","sortedLogs","sort","a","b","Date","date","getTime","length","today","yesterday","setDate","getDate","todayLog","find","yesterdayLog","streak","currentDate","i","logDate","daysDiff","calculateEstimatedDays","remainingDeficit","dailyDeficit","Infinity","ceil","calculateAverageDailyDeficit","totalDeficit","sum","calculateBMI","weight","height","heightInMeters","getBMICategory","bmi"],"sources":["/Users/sudeepch/butterloss/src/utils/calculations.ts"],"sourcesContent":["import { DailyLog } from '../types';\nimport { isSameDay } from 'date-fns';\n\n// Constants\nconst CALORIES_PER_KG_FAT = 7716.17; // calories needed to lose 1kg of fat\nconst CALORIES_PER_BUTTER_PACK = 770; // 770 calories = 1 butter pack (100g fat)\nconst CALORIES_PER_GHEE_PACK = 7700; // 7700 calories = 1 ghee pack (1kg fat)\n\nexport const calculateTotalDeficitNeeded = (targetLoss: number): number => {\n  const exactDeficit = targetLoss * CALORIES_PER_KG_FAT;\n  // Round to nearest 100 calories for a nice round number\n  return Math.round(exactDeficit / 100) * 100;\n};\n\nexport const calculateCurrentDeficit = (logs: DailyLog[]): number => {\n  return logs.reduce((total, log) => total + (log.deficit || 0), 0);\n};\n\nexport const calculateRemainingDeficit = (totalNeeded: number, current: number): number => {\n  return Math.max(0, totalNeeded - current);\n};\n\nexport const calculateButterPacks = (logs: DailyLog[]): number => {\n  // Only count positive deficits for butter packs\n  const positiveDeficit = logs.reduce((total, log) => total + Math.max(0, log.deficit || 0), 0);\n  return Math.floor(positiveDeficit / CALORIES_PER_BUTTER_PACK);\n};\n\nexport const calculateGheePacks = (logs: DailyLog[]): number => {\n  // Only count positive deficits for ghee packs\n  const positiveDeficit = logs.reduce((total, log) => total + Math.max(0, log.deficit || 0), 0);\n  return Math.floor(positiveDeficit / CALORIES_PER_GHEE_PACK);\n};\n\nexport const calculateCurrentStreak = (logs: DailyLog[]): number => {\n  // Sort logs by date in descending order (most recent first)\n  const sortedLogs = [...logs].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n  \n  if (sortedLogs.length === 0) return 0;\n  \n  const today = new Date();\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n  \n  // Check if we have an entry for today\n  const todayLog = sortedLogs.find(log => isSameDay(new Date(log.date), today));\n  const yesterdayLog = sortedLogs.find(log => isSameDay(new Date(log.date), yesterday));\n  \n  // If no entry for today, check if yesterday had a positive deficit\n  if (!todayLog) {\n    if (!yesterdayLog || (yesterdayLog.deficit || 0) <= 0) {\n      return 0; // No streak if yesterday is missing or had non-positive deficit\n    }\n    // Yesterday had positive deficit but no today entry - streak is 1\n    return 1;\n  }\n  \n  // If today's entry exists but is not positive, no streak\n  if ((todayLog.deficit || 0) <= 0) {\n    return 0;\n  }\n  \n  // Start counting from today\n  let streak = 1;\n  let currentDate = new Date(todayLog.date);\n  \n  // Check consecutive days backwards\n  for (let i = 1; i < sortedLogs.length; i++) {\n    const log = sortedLogs[i];\n    const logDate = new Date(log.date);\n    const daysDiff = Math.floor((currentDate.getTime() - logDate.getTime()) / (1000 * 60 * 60 * 24));\n    \n    if (daysDiff === 1 && (log.deficit || 0) > 0) {\n      streak++;\n      currentDate = logDate;\n    } else {\n      break; // Gap in days or non-positive deficit, streak broken\n    }\n  }\n  \n  return streak;\n};\n\nexport const calculateEstimatedDays = (remainingDeficit: number, dailyDeficit: number): number => {\n  if (dailyDeficit <= 0) return Infinity;\n  return Math.ceil(remainingDeficit / dailyDeficit);\n};\n\nexport const calculateAverageDailyDeficit = (logs: DailyLog[]): number => {\n  if (logs.length === 0) return 0;\n  const totalDeficit = logs.reduce((sum, log) => sum + (log.deficit || 0), 0);\n  return totalDeficit / logs.length;\n};\n\nexport const calculateBMI = (weight: number, height: number): number => {\n  const heightInMeters = height / 100;\n  return weight / (heightInMeters * heightInMeters);\n};\n\nexport const getBMICategory = (bmi: number): string => {\n  if (bmi < 18.5) return 'Underweight';\n  if (bmi < 25) return 'Normal weight';\n  if (bmi < 30) return 'Overweight';\n  return 'Obese';\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}